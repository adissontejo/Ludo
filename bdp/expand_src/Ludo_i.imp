/* Ludo_i
 * Author: LENOVO
 * Creation date: 03/07/2025
 */

IMPLEMENTATION Ludo_i
REFINES Ludo

SEES Ludo_ctx
IMPORTS
  Ludo_board ,
  Ludo_turn

PROMOTES
  pickColor , unpickColor , endGame , getDiceValue

DEFINITIONS
  // ponto final externo
  finishPoint ( color ) == ( startPoint ( color ) + numExternal - 2 ) mod numExternal ;


  stepsDiff ( n1 , n2 ) == ( n2 - n1 + numExternal ) mod numExternal ;


  stepsToFinish_def ( piece ) == stepsDiff ( externalPos ( piece ) , finishPoint ( colorOf ( piece ) ) ) ;

  isPathFree_def ( n1 , n2 ) == ! nn . (
    nn : 0 .. numExternal - 1 & nn /= n1 & stepsDiff ( n1 , nn ) <= stepsDiff ( n1 , n2 ) =>
    card ( externalPos |> { nn } ) < 2
  )

LOCAL_OPERATIONS
  nn <-- stepsToFinish ( piece ) =
    PRE piece : PIECES
    THEN nn := stepsToFinish_def ( piece )
    END ;

  bb <-- isFinished ( cc ) =
    PRE cc : COLORS
    THEN bb := bool ( colorOf ~ [ { color } ] <: internalPos ~ [ { numInternal - 1 } ] )
    END ;

  bb <-- canFree ( pp ) =
    PRE pp : PIECES
    THEN
      bb := bool (
        diceValue = 6 &
        pp : lockedPieces &
        card ( externalPos |> { startPoint ( colorOf ( pp ) ) } ) < 2
      )
    END ;

  bb <-- isPathFree ( n1 , n2 ) =
    PRE n1 : 0 .. 51 & n2 : 0 .. 51
    THEN
      bb := bool ( isPathFree_def ( n1 , n2 ) )
    END ;

  bb <-- canWalk ( pp ) =
    PRE pp : PIECES
    THEN
      bb := bool (
        diceValue /= 0 &
        pp /: lockedPieces &
        ( pp : dom ( externalPos ) =>
          (
            diceValue <= stepsToFinish_def ( pp ) &
            isPathFree_def ( externalPos ( pp ) , ( externalPos ( pp ) + diceValue ) mod numExternal )
          ) or (
            diceValue - stepsToFinish_def ( pp ) - 1 < numInternal &
            isPathFree_def ( externalPos ( pp ) , finishPoint ( colorOf ( pp ) ) )
          )
        ) &
        ( pp : dom ( internalPos ) =>
          internalPos ( pp ) + diceValue < numInternal
        )
      )
    END

OPERATIONS
  nn <-- stepsToFinish ( piece ) =
    VAR externalPos , internalPos IN
        externalPos , internalPos <-- getPos ( piece ) ;
        nn := stepsDiff ( externalPos , finishPoint ( colorOf ( piece ) ) )
    END ;

  bb <-- isFinished ( cc ) =
    BEGIN
        bb := TRUE ;
        VAR ii , piece , pieceColor , dummy , pos , endPos IN
            ii := 0 ;
            endPos := numInternal - 1 ;
            WHILE ii < numPieces & bb = TRUE
              DO
                piece := piecesOrder ( ii ) ;
                pieceColor := colorOf ( piece ) ;
                dummy , pos <-- getPos ( piece ) ;

                IF pieceColor = cc & pos /= endPos THEN
                    bb := FALSE
                END ;
                ii := ii + 1

            INVARIANT
                ii : 0 .. numPieces &
                bb = TRUE <=> colorOf ~ [ { cc } ] /\ piecesOrder [ 0 .. ii - 1 ] <: internalPos ~ [ { numInternal - 1 } ]
            VARIANT numPieces - ii
            END
        END
    END ;

  bb <-- canFree ( pp ) =
    BEGIN
      bb := TRUE
    END ;

  bb <-- isPathFree ( n1 , n2 ) =
    VAR countPerPos , ii , piece , pos , dummy , numSteps , count IN
      countPerPos := ( 0 .. numExternal ) * { 0 } ;
      ii := 0 ;
      WHILE ii < numPieces
      DO
        piece := piecesOrder ( ii ) ;
        pos , dummy <-- getPos ( piece ) ;
        countPerPos ( pos ) := countPerPos ( pos ) + 1 ;
        ii := ii + 1
      INVARIANT
        ii : 0 .. numPieces &
        countPerPos : 0 .. numExternal --> NAT &
        countPerPos = % nn . ( nn : 0 .. numExternal - 1 | card ( ( piecesOrder [ 0 .. ii - 1 ] <| externalPos ) |> { nn } ) )
      VARIANT numPieces - ii
      END ;
      ii := 1 ;
      numSteps := stepsDiff ( n1 , n2 ) ;
      bb := TRUE ;
      WHILE ii <= numSteps & bb = TRUE
      DO
        count := countPerPos ( ( n1 + ii ) mod numExternal ) ;
        IF count >= 2 THEN
          bb := FALSE
        END ;
        ii := ii + 1
      INVARIANT
        ii : 1 .. numSteps + 1 &
        bb = bool ( ! nn . (
          nn : 0 .. numExternal - 1 & nn /= n1 & stepsDiff ( n1 , nn ) <= ii =>
          card ( externalPos |> { nn } ) < 2
        ) )
      VARIANT numSteps - ii + 1
      END
    END ;

  bb <-- canWalk ( pp ) =
    BEGIN
      bb := TRUE
    END ;


  startGame =
    BEGIN
      initGame ;
      clear
    END ;


  free ( pp ) =
    BEGIN
      computeAction ( FALSE , FALSE ) ;
      setFree ( pp )
    END ;


  vv <-- throwDice =
    BEGIN
      vv <-- rollDice
    END ;

  skipTurn =
    BEGIN
      nextTurn
    END ;


  walk ( pp ) =
    VAR externalPos , internalPos , diceValue , nn , newPos , endPos , atePiece , finished IN
      externalPos , internalPos <-- getPos ( pp ) ;
      diceValue <-- getDiceValue ;
      nn <-- stepsToFinish ( pp ) ;
      IF ( externalPos /= - 1 & diceValue <= nn ) THEN
          newPos := ( diceValue + externalPos ) mod numExternal ;
          atePiece <-- setExternalPos ( pp , newPos ) ;
          computeAction ( atePiece , FALSE )
      ELSE
          IF externalPos /= - 1 THEN
              newPos := diceValue - nn - 1
          ELSE
              newPos := diceValue + internalPos
          END ;
          setInternalPos ( pp , newPos ) ;
          endPos := numInternal - 1 ;
          IF newPos = endPos THEN
              finished <-- isFinished ( colorOf ( pp ) ) ;
              IF finished = TRUE THEN
                  computeAction ( FALSE , TRUE )
              ELSE
                  computeAction ( TRUE , FALSE )
              END
          END
      END
    END ;


  ee , ii <-- getPiecePos ( pp ) =
    BEGIN
      ee , ii <-- getPos ( pp )
    END ;


  cc <-- getTurn =
    BEGIN
      cc <-- getColor
    END ;

  nn <-- getNumWinners =
      nn <-- numWinners ;

  cc <-- getPlacement ( nn ) =
      cc <-- placement ( nn ) ;

// operações de pre condicao

  rr <-- pre_pickColor ( cc ) =
    BEGIN
      //rr := bool(cc /: enabledColors & gameStarted = FALSE)
      rr := TRUE
    END ;

  rr <-- pre_unpickColor ( cc ) =
    BEGIN
      //rr := bool(cc /: enabledColors & gameStarted = FALSE)
      rr := TRUE
    END ;

  rr <-- pre_initGame =
    BEGIN
      rr := TRUE
    END ;

  rr <-- pre_free ( pp ) =
    BEGIN
      //rr := bool(gameStarted = TRUE & colorOf(pp) = color & canFree(pp))
      rr := TRUE
    END ;

  rr <-- pre_rollDice =
    BEGIN
      //rr := bool(gameStarted = TRUE & hasRoll = TRUE & (diceValue = 0 or not(hasActions)));
      rr := TRUE
    END ;

  rr <-- pre_walk ( pp ) =
    BEGIN
      //rr := bool(gameStarted = TRUE & colorOf(pp) = color & canWalk(pp))
      rr := TRUE
    END ;

  rr <-- pre_nextTurn =
    BEGIN
      rr := TRUE
    END ;

  rr <-- pre_finishGame =
      rr := TRUE
END

/* Ludo_i
 * Author: LENOVO
 * Creation date: 03/07/2025
 */

IMPLEMENTATION Ludo_i
REFINES Ludo

SEES Ludo_ctx
IMPORTS
  Ludo_board,
  Ludo_turn
  
PROMOTES
  pickColor, unpickColor, endGame, getDiceValue, getGameStarted

DEFINITIONS
  // ponto final externo
  finishPoint(color) == (startPoint(color) + numExternal - 2) mod numExternal;

  // diferença entre duas posições externas
  stepsDiff(n1, n2) == (n2 - n1 + numExternal) mod numExternal;

  // quantidade de passos para chegar no ponto final externo
  stepsToFinish_def(piece) == stepsDiff(externalPos(piece), finishPoint(colorOf(piece)));

  isPathFree_def(n1, n2) == !nn . (
    nn : 0..numExternal-1 & nn /= n1 & stepsDiff(n1, nn) <= stepsDiff(n1, n2) =>
    card(externalPos |> {nn}) < 2
  );
  
  canFree_def(pp) ==
    diceValue = 6 &
    pp : lockedPieces &
    card(externalPos |> {startPoint(colorOf(pp))}) < 2;

  // verifica se a peça pode andar
  canWalk_def(pp)==
    diceValue /= 0 &
    pp /: lockedPieces &
    (pp : dom(externalPos) =>
      (
        diceValue <= stepsToFinish_def(pp) &
        isPathFree_def(externalPos(pp), (externalPos(pp) + diceValue) mod numExternal)
      ) or (
        diceValue - stepsToFinish_def(pp) - 1 < numInternal &
        isPathFree_def(externalPos(pp), finishPoint(colorOf(pp)))
      )
    ) &
    (pp : dom(internalPos) =>
      internalPos(pp) + diceValue < numInternal
    )

LOCAL_OPERATIONS
  nn <-- stepsToFinish(piece) =
    PRE piece : PIECES
    THEN nn := stepsToFinish_def(piece)
    END;

  bb <-- isFinished(cc) =
    PRE cc : COLORS
    THEN bb := bool(colorOf~[{color}] <: internalPos~[{numInternal-1}])
    END;

  bb <-- canFree(pp) =
    PRE pp : PIECES
    THEN
      bb := bool(
        diceValue = 6 &
        pp : lockedPieces &
        card(externalPos |> {startPoint(colorOf(pp))}) < 2
      )
    END;

  bb <-- isPathFree(n1, n2) =
    PRE n1 : 0..51 & n2 : 0..51
    THEN
      bb := bool(isPathFree_def(n1, n2))
    END;

  bb <-- canWalk(pp) =
    PRE pp : PIECES
    THEN
      bb := bool(
        diceValue /= 0 &
        pp /: lockedPieces &
        (pp : dom(externalPos) =>
          (
            diceValue <= stepsToFinish_def(pp) &
            isPathFree_def(externalPos(pp), (externalPos(pp) + diceValue) mod numExternal)
          ) or (
            diceValue - stepsToFinish_def(pp) - 1 < numInternal &
            isPathFree_def(externalPos(pp), finishPoint(colorOf(pp)))
          )
        ) &
        (pp : dom(internalPos) =>
          internalPos(pp) + diceValue < numInternal
        )
      )
    END;
    
  bb <-- hasActions =
      bb := bool(# pp . (pp : PIECES & colorOf(pp) = color & (canFree_def(pp) or canWalk_def(pp))))

OPERATIONS
  nn <-- stepsToFinish(piece) =
    VAR externalPos, internalPos IN
        externalPos, internalPos <-- getPos(piece);
        nn := stepsDiff(externalPos, finishPoint(colorOf(piece)))
    END;

  bb <-- isFinished(cc) =
    BEGIN
        bb := TRUE;
        VAR ii, piece, pieceColor, dummy, pos, endPos IN
            ii := 0;
            endPos := numInternal-1;
            WHILE ii < numPieces & bb = TRUE
              DO
                piece := piecesOrder(ii);
                pieceColor := colorOf(piece);
                dummy, pos <-- getPos(piece);

                IF pieceColor = cc & pos /= endPos THEN
                    bb := FALSE
                END;
                ii := ii + 1

            INVARIANT
                ii : 0..numPieces &
                bb = TRUE <=> colorOf~[{cc}] /\ piecesOrder[0..ii-1] <: internalPos~[{numInternal-1}]
            VARIANT numPieces - ii
            END
        END
    END;

  bb <-- canFree(pp) =
      
    BEGIN
     VAR diceValue, isLockedPiece, startPointColor, colorPiece, piece, color, ii, externalPosPiece, internalPosPiece, countStart
      IN
        diceValue <-- getDiceValue;
        isLockedPiece <-- isLocked(pp);
        colorPiece := colorOf(pp);
        
        IF diceValue = 6 & isLockedPiece = TRUE THEN
            
          startPointColor := startPoint(colorPiece);
          bb := FALSE;
          ii := 0;
          countStart := 0;
          
          WHILE ii < numPieces
          DO 
            piece := piecesOrder(ii);
            color := colorOf(piece);
            externalPosPiece, internalPosPiece <-- getPos(piece);
            IF externalPosPiece =  startPointColor THEN
                countStart := countStart + 1
            END;
            ii := ii + 1
          INVARIANT ii <= numPieces & countStart : NAT & countStart = card((piecesOrder[0..ii-1] <| externalPos) |> {startPointColor}) 
          VARIANT numPieces - ii
          END;
            
          IF countStart < 2 THEN
              bb := TRUE
          END
          
        ELSE
          bb := FALSE
        END
      END
    END;
    

  bb <-- isPathFree(n1, n2) =
    VAR countPerPos, ii, piece, pos, dummy, numSteps, count IN
      countPerPos := (0..numExternal) * {0};
      ii := 0;
      WHILE ii < numPieces
      DO
        piece := piecesOrder(ii);
        pos, dummy <-- getPos(piece);
        countPerPos(pos) := countPerPos(pos) + 1;
        ii := ii + 1
      INVARIANT
        ii : 0..numPieces &
        countPerPos : 0..numExternal --> NAT &
        countPerPos = % nn . (nn : 0..numExternal-1 | card((piecesOrder[0..ii-1] <| externalPos) |> {nn}))
      VARIANT numPieces - ii
      END;
      ii := 1;
      numSteps := stepsDiff(n1, n2);
      bb := TRUE;
      WHILE ii <= numSteps & bb = TRUE
      DO
        count := countPerPos((n1 + ii) mod numExternal);
        IF count >= 2 THEN
          bb := FALSE
        END;
        ii := ii + 1
      INVARIANT
        ii : 1..numSteps+1 &
        bb = bool(!nn . (
          nn : 0..numExternal-1 & nn /= n1 & stepsDiff(n1, nn) <= ii =>
          card(externalPos |> {nn}) < 2
        ))
      VARIANT numSteps - ii + 1
      END
    END;

  bb <-- canWalk(pp) =
    BEGIN
     VAR diceValue, isLockedPiece, colorPiece, externalPosPiece, internalPosPiece, sumInternal, stepsFinish, finishDiff
      IN
        diceValue <-- getDiceValue;
        isLockedPiece <-- isLocked(pp);
        colorPiece := colorOf(pp);
        externalPosPiece, internalPosPiece <-- getPos(pp);
        bb := FALSE;
        
        IF diceValue /= 0 & isLockedPiece = FALSE THEN
          bb := FALSE;
          sumInternal := internalPosPiece + diceValue;
          stepsFinish <-- stepsToFinish(pp);

            IF externalPosPiece >= 0 THEN
              finishDiff := diceValue - stepsFinish - 1;
          
              IF diceValue <= stepsFinish THEN
                bb <-- isPathFree(externalPosPiece, (externalPosPiece + diceValue) mod numExternal)
              ELSIF finishDiff < numInternal THEN
                bb <-- isPathFree(externalPosPiece, finishPoint(colorOf(pp)))
              END
            ELSIF sumInternal < numInternal THEN
              bb := TRUE
            END
         END  
    END
  END;
    
  bb <-- hasActions = 
  BEGIN
      VAR ii, piece, pieceColor, canFreePiece, canWalkPiece, color
      IN
          ii := 0;
          bb := FALSE;
          color <-- getColor;
          WHILE ii < numPieces & bb = FALSE
          DO 
            piece := piecesOrder(ii);
            pieceColor := colorOf(piece);
            canFreePiece <-- canFree(piece);
            canWalkPiece <-- canWalk(piece);
            IF pieceColor = color & (canFreePiece = TRUE or canWalkPiece = TRUE) THEN
                bb := TRUE
            END;
            ii := ii + 1
          INVARIANT ii <= numPieces & bb = TRUE <=> (# pp . (pp : PIECES & colorOf(pp) = color & (canFree_def(pp) or canWalk_def(pp))  & pp : piecesOrder[0..ii-1]))
          VARIANT numPieces - ii
          END
      END
  END;


  startGame =
    BEGIN
      initGame;
      clear
    END;


  free(pp) =
    BEGIN
      computeAction(FALSE, FALSE);
      setFree(pp)
    END;


  vv <-- throwDice =
    BEGIN
      vv <-- rollDice
    END;

  skipTurn =
    BEGIN
      nextTurn
    END;


  walk(pp) =
    VAR externalPos, internalPos, diceValue, nn, newPos, endPos, atePiece, finished IN
      externalPos, internalPos <-- getPos(pp);
      diceValue <-- getDiceValue;
      nn <-- stepsToFinish(pp);
      IF (externalPos /= -1 & diceValue <= nn) THEN
          newPos := (diceValue + externalPos) mod numExternal;
          atePiece <-- setExternalPos(pp, newPos);
          computeAction(atePiece, FALSE)
      ELSE
          IF externalPos /= -1 THEN
              newPos := diceValue - nn - 1
          ELSE
              newPos := diceValue + internalPos
          END;
          setInternalPos(pp, newPos);
          endPos := numInternal - 1;
          IF newPos = endPos THEN
              finished <-- isFinished(colorOf(pp));
              IF finished = TRUE THEN
                  computeAction(FALSE, TRUE)
              ELSE
                  computeAction(TRUE, FALSE)
              END
          END
      END
    END;


  ee, ii <-- getPiecePos(pp) =
    BEGIN
      ee, ii <-- getPos(pp)
    END;


  cc <-- getTurn =
    BEGIN
      cc <-- getColor
    END;

  nn <-- getNumWinners =
      nn <-- numWinners;

  cc <-- getPlacement(nn) =
      cc <-- placement(nn);

// operações de pre condicao

  rr <-- pre_pickColor(cc) =
    BEGIN
      VAR isGameStarted, isEnabled
      IN
        isGameStarted <-- getGameStarted;
        isEnabled <-- isColorEnabled(cc);

        IF isGameStarted = FALSE & isEnabled = FALSE THEN    
            rr := TRUE
        ELSE
            rr := FALSE
        END
      END
    END;

  rr <-- pre_unpickColor(cc) =
    BEGIN
      VAR isGameStarted, isEnabled
      IN
        isGameStarted <-- getGameStarted;
        isEnabled <-- isColorEnabled(cc);

        IF isGameStarted = FALSE & isEnabled = TRUE THEN    
            rr := TRUE
        ELSE
            rr := FALSE
        END
      END
    END;

  rr <-- pre_initGame =
    BEGIN
      VAR isGameStarted, ii, isEnabled, color, countEnableds
      IN
        isGameStarted <-- getGameStarted;
        IF isGameStarted = FALSE THEN
            ii := 0;
            countEnableds := 0;
            rr := FALSE;
            WHILE ii < 4 & rr = FALSE
            DO
              color := colorsOrder(ii);
              isEnabled <-- isColorEnabled(color);
              
              IF isEnabled = TRUE THEN
                  countEnableds := countEnableds + 1
              END;
              
              IF countEnableds = 2 THEN
                  rr := TRUE
              END;
              ii := ii + 1
        
            INVARIANT
              ii : NAT & ii <= 4 & isGameStarted : BOOL & countEnableds : 0..4 &
              rr = TRUE <=> (countEnableds = card(enabledColors /\ colorsOrder[0..ii-1]) & countEnableds >= 2)
            VARIANT 4 - ii
            END
         ELSE
             rr := FALSE
         END
      END
    END;

  rr <-- pre_free(pp) =
    BEGIN
     VAR isGameStarted, color, colorPiece, isCanFree
      IN
        isGameStarted <-- getGameStarted;
        colorPiece := colorOf(pp);
        color <-- getColor;
        isCanFree <-- canFree(pp);

        IF isGameStarted = TRUE & colorPiece = color & isCanFree = TRUE THEN    
            rr := TRUE
        ELSE
            rr := FALSE
        END
      END
    END;

  rr <-- pre_rollDice =
    BEGIN
     VAR isGameStarted, diceValue, hasRoll, isHasActions
      IN
        isGameStarted <-- getGameStarted;
        diceValue <-- getDiceValue;
        hasRoll <-- getHasRoll;
        isHasActions <-- hasActions;
        
        IF isGameStarted = TRUE & hasRoll = TRUE & (diceValue = 0 or isHasActions = FALSE) THEN
          rr := TRUE
        ELSE
          rr := FALSE
        END
      END
    END;
    
  rr <-- pre_walk(pp) =
    BEGIN
     VAR isGameStarted, color, colorPiece, isCanWalk
      IN
        isGameStarted <-- getGameStarted;
        colorPiece := colorOf(pp);
        color <-- getColor;
        isCanWalk <-- canWalk(pp);

        IF isGameStarted = TRUE & colorPiece = color & isCanWalk = TRUE THEN    
            rr := TRUE
        ELSE
            rr := FALSE
        END
      END
    END;

  rr <-- pre_nextTurn =
    BEGIN
      //      rr := bool(gameStarted = TRUE & hasRoll = FALSE & (diceValue = 0 or not(hasActions)) & card(finishOrder) < card(enabledColors));
      rr := TRUE
    END;
      
  rr <-- pre_finishGame =
    BEGIN
     VAR isGameStarted, finishCount
      IN
        isGameStarted <-- getGameStarted;
        finishCount <-- getFinishCount;

        IF isGameStarted = TRUE & finishCount >= 1 THEN    
            rr := TRUE
        ELSE
            rr := FALSE
        END
      END
    END
END

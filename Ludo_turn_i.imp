/* Ludo_turn_i
 * Author: anaca
 * Creation date: 25/06/2025
 */

IMPLEMENTATION Ludo_turn_i
REFINES Ludo_turn

SEES Ludo_ctx
IMPORTS Random


CONCRETE_VARIABLES
  gameStarted,
  colorEnabled, //concrete
  color,
  hasRoll,
  diceValue,
  sixSequenceCount,
  finishList,
  finishCount

INVARIANT
  finishList : 0..3 --> COLORS &
  finishCount : 0..4 &
  0..finishCount-1 <| finishList = finishOrder &
  finishCount = card(finishOrder) &
  colorEnabled : COLORS --> BOOL &
  dom(colorEnabled |> {TRUE}) = enabledColors

INITIALISATION
  gameStarted := FALSE;
  colorEnabled := COLORS * {FALSE};
  color := colorsOrder(0);
  hasRoll := FALSE;
  diceValue := 0;
  sixSequenceCount := 0;
  finishList := colorsOrder;
  finishCount := 0


LOCAL_OPERATIONS
   bb <-- isColorFinished(cc) =
       PRE cc : COLORS
       THEN
           bb := bool(cc : ran(finishList))
       END;

   nn <-- turnIndex =
       nn := colorsOrder~(color)

OPERATIONS

  bb <-- isColorFinished(cc) =
  BEGIN
      VAR ii, color IN
          ii := 0;
          bb := FALSE;
          WHILE ii < finishCount & bb = FALSE
          DO
            color := finishList(ii);
            bb := bool(color = cc);
            ii := ii + 1
          INVARIANT ii : 0..finishCount & ((bb = TRUE) <=> (cc : finishList[0..ii-1]))
          VARIANT numColors - ii
          END
      END
  END;

  nn <-- turnIndex =
  BEGIN
      VAR ii, isColorTurn, cc IN
          ii := 0;
          cc := colorsOrder(ii);
          isColorTurn := bool(cc = color);
          WHILE isColorTurn = FALSE
          DO
            ii := ii + 1;
            cc := colorsOrder(ii);
            isColorTurn := bool(cc = color)
          INVARIANT ii : 0..numColors & isColorTurn = bool(colorsOrder(ii) = color)
          VARIANT numColors - ii
          END;
          nn := ii
      END
  END;

  pickColor(cc) =
    BEGIN
      colorEnabled(cc) := TRUE
    END;


  unpickColor(cc) =
    BEGIN
      colorEnabled(cc) := FALSE
    END;


  initGame =
    BEGIN
      gameStarted := TRUE;
      VAR ii, vv, enabledList, enabledCount, isEnabled IN
          ii := 0;
          enabledList := (0..4) * {colorsOrder(0)};
          enabledCount := 0;
          WHILE ii < numColors
          DO
            isEnabled := colorEnabled(colorsOrder(ii));
            IF isEnabled = TRUE THEN
              enabledList(enabledCount) := colorsOrder(ii);
              enabledCount := enabledCount + 1
            END;
            ii := ii + 1
          INVARIANT
            ii : 0..(numColors - 1)
            & enabledList : 0..4 --> COLORS
            & enabledList[0..enabledCount-1] = enabledColors /\ colorsOrder[0..ii-1]
            & enabledCount = card(enabledColors /\ colorsOrder[0..ii-1])
          VARIANT numColors - ii
          END;
          vv <-- getRandomInt(0, enabledCount - 1);
          color := enabledList(vv)
      END;
      hasRoll := TRUE;
      diceValue := 0;
      sixSequenceCount := 0;
      finishList := colorsOrder;
      finishCount := 0
    END;


  // zera o valor do dado atual, e caso a peÃ§a tenha turno extra ele altera hasRoll pra TRUE
  computeAction(extraTurn, finished) =
    BEGIN
      diceValue := 0;
      IF finished = TRUE
        THEN
          finishList(finishCount) := color;
          finishCount := finishCount + 1;
          hasRoll := FALSE
      ELSIF extraTurn = TRUE
        THEN
          hasRoll := TRUE
      END
    END;


  nextTurn =
    BEGIN
      VAR numJumps, cc, isFinished, currentIndex, enabled, isValid
      IN
          currentIndex <-- turnIndex;
          numJumps := 1;
          cc := colorsOrder((currentIndex + 1) mod numColors);
          enabled := colorEnabled(cc);
          isFinished <-- isColorFinished(cc);
          isValid := bool(enabled = TRUE & isFinished = FALSE);
          WHILE isValid = FALSE
          DO

              numJumps := numJumps + 1;
              cc := colorsOrder((currentIndex + numJumps) mod numColors);
              enabled := colorEnabled(cc);
              isFinished <-- isColorFinished(cc);
              isValid := bool(enabled = TRUE & isFinished = FALSE)

          INVARIANT 
            numJumps <= numColors &
            isValid : BOOL &
            isValid = bool(colorsOrder((currentIndex + numJumps) mod numColors) : enabledColors - ran(finishOrder)) &
            { nn |
              nn : 1..numJumps-1 & colorsOrder((currentIndex + nn) mod numColors) : enabledColors - ran(finishOrder)
            } = {}
          VARIANT numColors - numJumps
          END;
          hasRoll := TRUE;
          sixSequenceCount := 0;
          diceValue := 0;
          color := colorsOrder((currentIndex + numJumps) mod numColors)

      END
    END;


  value <-- rollDice =
    BEGIN
      VAR dd IN
        dd <-- getRandomInt(1, 6);
        value := dd;
        IF dd = 6 THEN
          IF sixSequenceCount < 2 THEN
            sixSequenceCount := sixSequenceCount + 1;
            diceValue := dd
          ELSE
            sixSequenceCount := 0;
            hasRoll := FALSE;
            diceValue := 0
          END
        ELSE
          sixSequenceCount := 0;
          hasRoll := FALSE;
          diceValue := dd
        END
      END
    END;


  endGame =
    BEGIN
        gameStarted := FALSE
    END;

  value <-- getDiceValue =
      value := diceValue;

  cc <-- getColor =
      cc := color;
  
  bb <-- getGameStarted  = 
      bb := gameStarted;
      
  bb <-- getHasRoll =
      bb := hasRoll;

  bb <-- isColorEnabled(cc) = 
      bb:= colorEnabled(cc);
      
  nn <-- getFinishCount =
      nn := finishCount;
      
  cc <-- getPlacement(nn) =
      cc := finishList(nn)
END
